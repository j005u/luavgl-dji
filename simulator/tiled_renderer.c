
#include <stdlib.h>
#include <unistd.h>
#define SDL_MAIN_HANDLED /*To fix SDL's "undefined reference to WinMain"       \
                            issue*/
#include "demos/lv_demos.h"
#include "examples/lv_examples.h"
#include <lvgl.h>

#include <lua.h>

#include <lauxlib.h>
#include <lualib.h>

#include <luavgl.h>
#include "extension.h"

#include "hw/dji_display.h"
#include "hw/dji_services.h"

typedef struct {
  lua_State *L;
  lv_obj_t *root;
} lua_context_t;

typedef struct {
  lv_obj_t *root;
  make_font_cb make_font;
  delete_font_cb delete_font;
} luavgl_args_t;

#define WIDTH 1440
#define HEIGHT 810
#define BYTES_PER_PIXEL 4
#define PLANE_ID 6
#define BUFSIZE WIDTH * 100


static dji_display_state_t *dji_display;
static void *fb0_addr;
static void *fb1_addr;
static int whichfb = 0;
static lv_color_t buf1_1[BUFSIZE];
static lv_color_t buf1_2[BUFSIZE];

void dji_display_flush(lv_disp_drv_t * drv, const lv_area_t * area, lv_color_t * color_p) {
  //printf("%p - %p - %p\n", fb0_addr, fb1_addr, (void*)color_p);
  //printf("x1 - %d \t x2 \t - %d \t y1 - %d \t y2 %d\n", area->x1, area->x2, area->y1, area->y2);
  //printf("w - %d \t h - %d\n", area->x2 - area->x1, area->y2 - area->y1);
  void* fb = (whichfb ? fb0_addr : fb1_addr);
  //int copylen = (area->x2 - area->x1)*BYTES_PER_PIXEL;

  /*uint32_t pixel_x = (x * display_info->font_width) + display_info->x_offset;
  uint32_t pixel_y = (y * display_info->font_height) + display_info->y_offset;
  uint32_t character_offset = (((display_info->font_height * display_info->font_width) * BYTES_PER_PIXEL) * c);
  for(uint8_t gx = 0; gx < display_info->font_width; gx++) {
      for(uint8_t gy = 0; gy < display_info->font_height; gy++) {
          uint32_t font_offset = character_offset + (gy * display_info->font_width * BYTES_PER_PIXEL) + (gx * BYTES_PER_PIXEL);
          uint32_t target_offset = ((((pixel_x + gx) * BYTES_PER_PIXEL) + ((pixel_y + gy) * WIDTH * BYTES_PER_PIXEL)));
          *((uint8_t *)fb_addr + target_offset) = *(uint8_t *)((uint8_t *)font + font_offset + 2);
          *((uint8_t *)fb_addr + target_offset + 1) = *(uint8_t *)((uint8_t *)font + font_offset + 1);
          *((uint8_t *)fb_addr + target_offset + 2) = *(uint8_t *)((uint8_t *)font + font_offset);
          *((uint8_t *)fb_addr + target_offset + 3) = ~*(uint8_t *)((uint8_t *)font + font_offset + 3);
      }
  }*/

  const uint32_t bufwidth = area->x2 - area->x1;
  const uint32_t bufheight = area->y2 - area->y1;
  for(uint32_t y=0;y<bufheight; y++) {
    for(uint32_t x=0;x<bufwidth; x++) {
      uint8_t * sp = (uint8_t *)((uint32_t)color_p) + (((y * bufwidth) + x) * BYTES_PER_PIXEL);
      uint8_t * dp = fb + ((((y + area->y1) * WIDTH) + (x + area->x1)) * BYTES_PER_PIXEL);

      dp[0] = sp[0];
      dp[1] = sp[1];
      dp[2] = sp[2];
      dp[3] = ~sp[3];
      //dp[3] = 0xff;

    }
  }

  if(lv_disp_flush_is_last(drv)) {
    dji_display_push_frame(dji_display, ((void*)buf1_1 == (void*)color_p ? 0 : 1));
    whichfb = !whichfb;
  }

  lv_disp_flush_ready(drv);
}

/**
 * Initialize the Hardware Abstraction Layer (HAL) for the LVGL graphics
 * library
 */
static void hal_init(void)
{
  dji_display = dji_display_state_alloc(dji_goggles_are_v2());
  dji_display_open_framebuffer(dji_display, PLANE_ID);

  /*Create a display buffer*/

  static lv_disp_draw_buf_t disp_buf1;
  fb0_addr = dji_display_get_fb_address(dji_display, 0);
  fb1_addr = dji_display_get_fb_address(dji_display, 1);
  memset(fb0_addr, 0x000000FF, WIDTH * HEIGHT * BYTES_PER_PIXEL);
  memset(fb1_addr, 0x000000FF, WIDTH * HEIGHT * BYTES_PER_PIXEL);
  lv_disp_draw_buf_init(&disp_buf1, buf1_1, buf1_2, BUFSIZE);

  /*Create a display*/
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv); /*Basic initialization*/
  disp_drv.draw_buf = &disp_buf1;
  disp_drv.flush_cb = dji_display_flush;
  disp_drv.hor_res = WIDTH;
  disp_drv.ver_res = HEIGHT;

  lv_disp_t *disp = lv_disp_drv_register(&disp_drv);

  lv_theme_t *th = lv_theme_default_init(
      disp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),
      LV_THEME_DEFAULT_DARK, LV_FONT_DEFAULT);
  lv_disp_set_theme(disp, th);

  lv_group_t *g = lv_group_create();
  lv_group_set_default(g);


}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char *pname, const char *msg)
{
  printf("%s: %s\n", pname ? pname : " ", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State *L, int status)
{
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message("luactx", msg);
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State *L)
{
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {                         /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)      /* that produces a string? */
      return 1;                              /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                            luaL_typename(L, 1));
  }

  /* append a standard traceback */
  luaL_traceback(L, L, msg, 1);

  msg = lua_tostring(L, -1);
  lua_pop(L, 1);

  lv_obj_t *root = NULL;
  luavgl_ctx_t *ctx = luavgl_context(L);
  root = ctx->root ? ctx->root : lv_scr_act();
  lv_obj_t *label = lv_label_create(root);
  lv_label_set_text(label, msg);
  lv_label_set_long_mode(label, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(label, LV_FONT_DEFAULT, 0);
  lv_obj_set_width(label, LV_PCT(80));
  lv_obj_center(label);

  printf("trace back: \n%s\n", msg);
  return 0; /* return no trace, since we already processed it. */
}

static int lua_panic(lua_State *L)
{
  printf("LUA panic:\n%s\n", lua_tostring(L, -1));
  return 0; /* return to Lua to abort */
}

/*
** protected main entry
*/
static int pmain(lua_State *L)
{
  int status;
  const char *script = lua_tostring(L, 1);

  luavgl_args_t *args = lua_touserdata(L, 2);
  if (args == NULL || args->root == NULL) {
    printf("Null root object.\n");
    return 0;
  }

  luavgl_set_root(L, args->root);
  luavgl_set_font_extension(L, args->make_font, args->delete_font);

  /**
   * Set global variable SCRIPT_PATH, to make image src path easier.
   */
  char *path = strdup(script);
  if (path == NULL) {
    printf("no memory.\n");
    return 0;
  }

  int i = strlen(path);
  for (; i; i--) {
    if (path[i] == '/') {
      path[i + 1] = '\0';
      break;
    }
  }

  printf("script path: %s\n", path);
  lua_pushstring(L, path);
  lua_setglobal(L, "SCRIPT_PATH");
  luaL_openlibs(L);

  lua_getglobal(L, "package");
  lua_getfield(L, -1, "path");

  const char *pkg_path = lua_tostring(L, -1);
  char *new_path = malloc(strlen(pkg_path) + strlen(script) + 2);
  strcpy(new_path, pkg_path);
  strcat(new_path, ";"), strcat(new_path, path), strcat(new_path, "?.lua");
  lua_pop(L, 1);
  lua_pushstring(L, new_path);
  lua_setfield(L, -2, "path");
  lua_pop(L, 1);
  free(path);
  free(new_path);

  lua_atpanic(L, &lua_panic);

  luaL_requiref(L, "lvgl", luaopen_lvgl, 1);
  lua_pop(L, 1);
  luavgl_extension_init(L);

  lua_pushcfunction(L, msghandler); /* push message handler */
  int base = lua_gettop(L);
  status = luaL_loadfile(L, script);
  if (status != LUA_OK) {
    lua_pushfstring(L, "failed to load: %s\n", script);
    /* manually show the error to screen. */
    lua_insert(L, 1);
    msghandler(L);
    return 0;
  }

  status = lua_pcall(L, 0, 0, base);
  lua_remove(L, base); /* remove message handler from the stack */
  report(L, status);
  lua_pushboolean(L, 1); /* signal no errors */
  return 1;
}

lua_context_t *lua_load_script(const char *script, luavgl_args_t *args)
{
  int ret, status;
  /* create the thread to run script. */
  if (script == NULL) {
    printf("args error.\n");
    return NULL;
  }

  printf("run script: %s\n", script);
  lua_State *L = luaL_newstate(); /* create state */
  if (L == NULL) {
    printf("no mem for lua state.\n");
    return NULL;
  }

  lua_pushcfunction(L, &pmain); /* to call 'pmain' in protected mode */
  lua_pushstring(L, script);
  lua_pushlightuserdata(L, args);
  status = lua_pcall(L, 2, 1, 0); /* do the call */
  ret = lua_toboolean(L, -1);
  report(L, status);
  if (!ret || status != LUA_OK) {
    /* This should never happen */
    printf("pcall failed.\n");
    lua_close(L);
    return NULL;
  }

  /* script may fail, but we continue until page destoried. */
  lua_context_t *luactx = calloc(sizeof(*luactx), 1);
  if (luactx == NULL) {
    printf("no memory.\n");
    goto lua_exit;
  }

  luactx->L = L;
  luactx->root = args->root;
  return luactx;

lua_exit:
  lua_close(L);

  return NULL;
}

int lua_terminate(lua_context_t *luactx)
{
  lua_State *L = luactx->L;

  lua_close(L);
  free(luactx);
  return 0;
}

static lua_context_t *lua_ctx;
static luavgl_args_t args;

static void reload_cb(lv_event_t *e)
{
  (void)e;
  if (lua_ctx != NULL) {
    lua_terminate(lua_ctx);
  }

  lua_ctx = lua_load_script(LUAVGL_EXAMPLE_DIR "/examples.lua", &args);
}

int main(int argc, char **argv)
{
  (void)argc; /*Unused*/
  (void)argv; /*Unused*/
  dji_stop_goggles(dji_goggles_are_v2());
  usleep(1000000);
  /*Initialize LVGL*/
  lv_init();

  /*Initialize the HAL (display, input devices, tick) for LVGL*/
  hal_init();

  args.root = lv_scr_act();

  lua_ctx = lua_load_script(LUAVGL_EXAMPLE_DIR "/examples.lua", &args);

  lv_obj_t *btn = lv_btn_create(lv_layer_sys());
  lv_obj_align(btn, LV_ALIGN_BOTTOM_RIGHT, 0, -50);
  lv_obj_set_size(btn, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
  lv_obj_set_style_pad_all(btn, 5, 0);
  lv_obj_add_event_cb(btn, reload_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t* label = lv_label_create(btn);
  lv_label_set_text(label, "RELOAD");
  lv_obj_center(label);

  while (1) {
    /* Periodically call the lv_task handler.
     * It could be done in a timer interrupt or an OS task too.*/
    lv_timer_handler();
    usleep(5 * 1000);
  }

  dji_display_close_framebuffer(dji_display);
  dji_display_state_free(dji_display);

  return 0;
}
